from datetime import datetime
from typing import Any, List, Optional
from bson import ObjectId
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from pydantic import BaseModel
from pymongo import DESCENDING

from db.client import MongoDBClient
from db.constants import (
    ChatHistoryFormType,
    ChatHistoryRole,
    ChatHistoryType,
    CollectionName,
)
from db.models import ChatHistory, EnglishWriting
from workflows.supervisor import build_supervisor
from workflows.states import SupervisorState


@asynccontextmanager
async def lifespan(app: FastAPI):
    print("FastAPI starting up...")
    MongoDBClient.get_client()
    yield
    print("FastAPI shutting down...")
    MongoDBClient.close()


app = FastAPI(lifespan=lifespan)

origins = [
    "http://localhost:5173",  # front-end url
]

# tackle with cross domain
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class ChatRequest(BaseModel):
    """
    Chat request model with temporary ID support for optimistic UI updates.

    The tempId is generated by frontend for immediate UI updates, while the server
    returns the actual database IDs for permanent storage reference.
    """

    tempId: str  # Frontend-generated temporary ID for optimistic UI
    role: ChatHistoryRole
    content: str
    type: Optional[ChatHistoryType]
    formType: Optional[ChatHistoryFormType] = None
    payload: Optional[Any] = None


@app.post("/chat")
async def chat(request: ChatRequest):
    """Main chat endpoint for processing user messages and form submissions"""
    print(">>>>>>>>>>enter /chat api")
    print(request)

    try:
        # Build and run supervisor workflow
        graph = build_supervisor()

        # Prepare state parameters
        graphDataParams = {
            "role": request.role,
            "userContent": request.content,
            "type": request.type,
        }

        # Add optional fields if present
        for field in ["formType", "payload"]:
            value = getattr(request, field, None)
            if value is not None:
                graphDataParams[field] = value

        # Execute workflow
        graphData = SupervisorState(**graphDataParams)
        result = graph.invoke(graphData)

        print(">>>>>>>workflow result")
        print(result)

        # Construct return data with ID mapping
        returnData = {
            # ID mapping for frontend to update optimistic UI
            "tempId": request.tempId,  # Original temp ID from frontend
            "userMsgId": result.get("userMsgId"),  # Database ID for user message
            "AIMsgId": result.get("AIMsgId"),  # Database ID for AI message
            # AI response message
            "AIMsg": {
                "_id": result.get("AIMsgId"),
                "role": ChatHistoryRole.AI,
                "type": result.get("type"),
                "content": result.get(
                    "AIContent",
                    "I'm having trouble processing your request. Please try again!",
                ),
            },
        }

        # Add optional response fields
        formType = result.get("formType")
        if formType:
            returnData["AIMsg"]["formType"] = formType

        payload = result.get("workflowResult")
        if payload:
            returnData["AIMsg"]["payload"] = payload

        print(">>>>>>>>>>return data")
        print(returnData)
        return returnData

    except Exception as e:
        print(f"Error in chat endpoint: {e}")

        # Return error response with temp ID for frontend error handling
        error_response = {
            "tempId": request.tempId,  # Include temp ID for frontend to identify failed message
            "error": True,
            "message": "I'm having trouble processing your request. Please try again!",
            "details": "Internal server error processing your request",
        }

        raise HTTPException(status_code=500, detail=error_response)


@app.get("/chats", response_model=List[ChatHistory])
def get_chats(limit: int = Query(30, gt=0), before: Optional[datetime] = None):
    # def get_chats():
    db = MongoDBClient.get_db()
    query = {}
    if before:
        query["created_at"] = {"$lt": before}  # get earlier messages

    chats = (
        db[CollectionName.CHATHISTORY.value]
        .find(query)
        .sort("created_at", DESCENDING)
        .limit(limit)
    )

    chats_list = list(chats)
    for chat in chats_list:
        chat["_id"] = str(chat["_id"])
    print(chats_list)
    chats_list.sort(key=lambda x: x["created_at"])
    return chats_list


@app.get("/writings", response_model=List[EnglishWriting])
def get_writings():
    db = MongoDBClient.get_db()
    writings = db[CollectionName.ENG_WRITINGS.value].find()
    writing_list = list(writings)
    for writing in writing_list:
        writing["_id"] = str(writing["_id"])
    print(writing_list)
    return writing_list


@app.get("/writings/{id}", response_model=EnglishWriting)
def get_writing_by_id(id: str):
    """Get a specific writing by ID"""
    db = MongoDBClient.get_db()
    try:
        object_id = ObjectId(id)
    except:
        raise HTTPException(status_code=400, detail="Invalid ObjectId format")

    writing = db[CollectionName.ENG_WRITINGS.value].find_one({"_id": object_id})
    if writing:
        writing["_id"] = str(writing["_id"])
        return writing
    else:
        raise HTTPException(status_code=404, detail="Writing not found")


@app.get("/analytics/summary")
def get_analytics_summary():
    """Get overall analytics summary for the student"""
    db = MongoDBClient.get_db()

    try:
        # Get writing statistics
        writing_count = db[CollectionName.ENG_WRITINGS.value].count_documents({})

        # Get average score
        pipeline = [
            {"$match": {"overall_score": {"$exists": True, "$ne": None}}},
            {"$group": {"_id": None, "avg_score": {"$avg": "$overall_score"}}},
        ]
        avg_result = list(db[CollectionName.ENG_WRITINGS.value].aggregate(pipeline))
        avg_score = avg_result[0]["avg_score"] if avg_result else 0

        # Get recent activity count
        recent_chats = db[CollectionName.CHATHISTORY.value].count_documents({})

        return {
            "total_writings": writing_count,
            "average_score": round(avg_score, 1),
            "total_interactions": recent_chats,
            "current_level": 1,  # Placeholder - would be calculated based on progress
            "total_points": writing_count * 10,  # Simple point system
        }
    except Exception as e:
        print(f"Error getting analytics: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving analytics")


@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "KidsProgress API"}
